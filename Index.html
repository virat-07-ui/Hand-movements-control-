<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Music + Hand Particles (Fixed)</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
  #ui { position: absolute; top: 20px; left: 20px; color: #0ff; z-index: 10; pointer-events: none; text-shadow: 0 0 5px #0ff; }
  #ui h3 { margin: 0; font-size: 20px; letter-spacing: 2px; }
  #ui p { margin: 5px 0; font-size: 13px; opacity: 0.9; }
  #videoBox {
    position: absolute; bottom: 20px; right: 20px;
    width: 180px; height: 135px;
    border: 2px solid #0ff; border-radius: 12px; overflow: hidden;
    transform: scaleX(-1); box-shadow: 0 0 15px rgba(0,255,255,0.5);
  }
  video { width: 100%; height: 100%; object-fit: cover; }
  #instructions {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: #0ff; text-align: center; cursor: pointer; z-index: 20;
    background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #0ff;
  }
</style>
</head>
<body>

<div id="instructions" onclick="initExperience()">
  <h2>NEON PARTICLES</h2>
  <p>Click to start Camera, Mic & Audio</p>
</div>

<div id="ui">
  <h3>NEON VISUALIZER</h3>
  <p id="modeText">MODE: SPHERE</p>
  <p>‚úä Fist = Attract | ü§è Pinch = Next Shape | üéµ Music = Pulse</p>
</div>

<div id="videoBox">
  <video id="video" autoplay playsinline></video>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
// ================= CONFIG & GLOBALS =================
const COUNT = 8000;
const TEXT_VALUE = "SURYA";
let shapeIndex = 0;
const shapes = ["sphere","cube","torus","spiral","dna","wave","heart","star","galaxy","vortex","infinity","text"];
let currentShape = shapes[shapeIndex];
let handX = 0, handY = 0, isFist = false, lastSwitch = 0;
let audioLevel = 0;
let actx, analyserMic, audioData;

// Reusable objects for performance (Prevents Garbage Collection stutters)
const tempV3 = new THREE.Vector3();
const tempCol = new THREE.Color();

// ================= THREE.JS SETUP =================
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 25;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// Create a glow texture for particles
const canvas = document.createElement('canvas');
canvas.width = 32; canvas.height = 32;
const ctx = canvas.getContext('2d');
const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
gradient.addColorStop(0, 'rgba(255,255,255,1)');
gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
gradient.addColorStop(1, 'rgba(255,255,255,0)');
ctx.fillStyle = gradient;
ctx.fillRect(0, 0, 32, 32);
const particleTexture = new THREE.CanvasTexture(canvas);

// ================= PARTICLES =================
const geo = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);

for (let i = 0; i < COUNT; i++) {
  positions[i * 3] = (Math.random() - 0.5) * 50;
  positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
  positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
}

geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const mat = new THREE.PointsMaterial({
  size: 0.15,
  vertexColors: true,
  transparent: true,
  blending: THREE.AdditiveBlending,
  map: particleTexture,
  depthWrite: false
});
const points = new THREE.Points(geo, mat);
scene.add(points);

// ================= TEXT POINTS GENERATION =================
const textPoints = [];
const tCanv = document.createElement("canvas");
tCanv.width = 600; tCanv.height = 200;
const tCtx = tCanv.getContext("2d");
tCtx.fillStyle = "white";
tCtx.font = "bold 100px Arial";
tCtx.textAlign = "center";
tCtx.fillText(TEXT_VALUE, 300, 120);
const imgData = tCtx.getImageData(0, 0, 600, 200).data;

for (let y = 0; y < 200; y += 3) {
  for (let x = 0; x < 600; x += 3) {
    if (imgData[(y * 600 + x) * 4] > 128) {
      textPoints.push({ x: (x - 300) / 15, y: (100 - y) / 15, z: 0 });
    }
  }
}

// ================= SHAPE MATH =================
function getShapePos(i) {
  const pulse = 1 + audioLevel * 2.5;
  const a = i / COUNT * Math.PI * 2;
  const u = (i % 100) / 100 * Math.PI * 2;
  const v = Math.floor(i / 100) / (COUNT / 100) * Math.PI;

  switch (currentShape) {
    case "sphere": return { x: 10 * pulse * Math.sin(v) * Math.cos(u), y: 10 * pulse * Math.sin(v) * Math.sin(u), z: 10 * pulse * Math.cos(v) };
    case "cube": return { x: ((i % 20) - 10) * pulse, y: ((Math.floor(i / 20) % 20) - 10) * pulse, z: ((Math.floor(i / 400) % 20) - 10) * pulse };
    case "torus": return { x: (10 + 3 * Math.cos(v)) * Math.cos(u) * pulse, y: (10 + 3 * Math.cos(v)) * Math.sin(u) * pulse, z: 3 * Math.sin(v) };
    case "spiral": return { x: Math.cos(a * 10) * i / 200 * pulse, y: Math.sin(a * 10) * i / 200 * pulse, z: (i / COUNT - 0.5) * 20 };
    case "dna": return { x: Math.cos(a * 15 + (i % 2 * Math.PI)) * 5 * pulse, y: (i / COUNT - 0.5) * 30, z: Math.sin(a * 15 + (i % 2 * Math.PI)) * 5 * pulse };
    case "heart": return { x: 0.6 * pulse * (16 * Math.pow(Math.sin(a), 3)), y: 0.6 * pulse * (13 * Math.cos(a) - 5 * Math.cos(2 * a) - 2 * Math.cos(3 * a) - Math.cos(4 * a)), z: (Math.random() - 0.5) * 2 };
    case "galaxy": return { x: Math.cos(a * 6) * (i / 200) * pulse, y: Math.sin(a * 6) * (i / 200) * pulse, z: (Math.random() - 0.5) * 5 };
    case "text": return textPoints[i % textPoints.length];
    default: return { x: 0, y: 0, z: 0 };
  }
}

// ================= CORE FUNCTIONS =================
function initExperience() {
  document.getElementById('instructions').style.display = 'none';
  
  // Audio Setup
  actx = new (window.AudioContext || window.webkitAudioContext)();
  analyserMic = actx.createAnalyser();
  analyserMic.fftSize = 256;
  audioData = new Uint8Array(analyserMic.frequencyBinCount);
  
  navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
    const src = actx.createMediaStreamSource(stream);
    src.connect(analyserMic);
  }).catch(e => console.log("Mic blocked"));

  // Hands Setup
  const video = document.getElementById("video");
  const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
  hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
  hands.onResults(onHandResults);

  const cameraHelper = new Camera(video, {
    onFrame: async () => { await hands.send({ image: video }); },
    width: 640, height: 480
  });
  cameraHelper.start();
}

function onHandResults(res) {
  if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
    const l = res.multiHandLandmarks[0];
    // Scale hand coords to 3D space
    handX = (0.5 - l[8].x) * 45; 
    handY = (0.5 - l[8].y) * 35;

    // Fist logic (Tip of index near base of index)
    isFist = Math.hypot(l[8].x - l[5].x, l[8].y - l[5].y) < 0.1;

    // Pinch logic (Thumb tip near index tip) for shape switch
    if (Math.hypot(l[4].x - l[8].x, l[4].y - l[8].y) < 0.04 && Date.now() - lastSwitch > 1000) {
      shapeIndex = (shapeIndex + 1) % shapes.length;
      currentShape = shapes[shapeIndex];
      document.getElementById("modeText").innerText = "MODE: " + currentShape.toUpperCase();
      lastSwitch = Date.now();
    }
  }
}

function animate() {
  requestAnimationFrame(animate);

  if (analyserMic) {
    analyserMic.getByteFrequencyData(audioData);
    audioLevel = audioData.reduce((a, b) => a + b) / (audioData.length * 255);
  }

  const pArr = geo.attributes.position.array;
  const cArr = geo.attributes.color.array;

  for (let i = 0; i < COUNT; i++) {
    const ix = i * 3;
    const dest = getShapePos(i);

    if (isFist) {
      pArr[ix] += (handX - pArr[ix]) * 0.12;
      pArr[ix + 1] += (handY - pArr[ix + 1]) * 0.12;
      pArr[ix + 2] += (0 - pArr[ix + 2]) * 0.12;
      tempCol.setHSL(0.9, 1, 0.6); // Red/Pink when attracting
    } else {
      pArr[ix] += (dest.x - pArr[ix]) * 0.06;
      pArr[ix + 1] += (dest.y - pArr[ix + 1]) * 0.06;
      pArr[ix + 2] += (dest.z - pArr[ix + 2]) * 0.06;
      tempCol.setHSL((Date.now() * 0.0001 + i / COUNT) % 1, 0.8, 0.5 + audioLevel * 0.4);
    }

    cArr[ix] = tempCol.r;
    cArr[ix + 1] = tempCol.g;
    cArr[ix + 2] = tempCol.b;
  }

  geo.attributes.position.needsUpdate = true;
  geo.attributes.color.needsUpdate = true;
  points.rotation.y += 0.002 + audioLevel * 0.03;
  
  renderer.render(scene, camera);
}

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>
</body>
</html>
